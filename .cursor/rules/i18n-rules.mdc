---
description: 多言語対応ルール
globs: app/**/*.*, packages/**/*.*,src/**/*.*
alwaysApply: true
---
# 多言語対応ルール

## 基本方針
- Next.jsのi18n機能を使用し、URLパスベースの言語切り替えを実装
- デフォルト言語は英語（en）
- 現在対応言語：英語（en）、日本語（ja）、スペイン語（es）
- 新規機能追加の際に既存のkeyは削除しない
- クライアントコンポーネントではNextの`Script`タグと`useMessages`フックを使用して翻訳を取得

## 実装ルール

### 1. ディレクトリ構造とルーティング
- トップページ以外のすべてのページは`app/[lang]/`配下に配置
- 各ツールは`app/[lang]/tools/[tool-name]/`もしくは`app/[lang]/[tool-name]/`に配置
- 画面遷移時はlang情報を必ず含める
- `next/link`を使用する場合は、以下のように言語パラメータを含める
```tsx
<Link href={`/${lang}/about`}>About</Link>
```

### 2. 言語フts/locales/[lang]/`ディレクトリ内で管理
  - 英語：`locales/en/`
  - 日本語：`locales/ja/`
  - スペイン語：`locales/es/`
- 各言語ディレクトリには以下のような構造で翻訳ファイルを配置：
  - `common.json` - 共通テキスト（ヘッダー、フッター、エラーメッセージなど）
  - `meta.json` - メタデータ（タイトル、説明文など）
  - 単一ツール用ファイル（例：`character-counter.json`、`number-quiz.json`）
  - カテゴリ別ディレクトリ（例：`pdf-tools/`）
    - カテゴリ共通ファイル: `[カテゴリ名]/common.json`
    - 個別ツールファイル: `[カテゴリ名]/[ツール名].json`

### 3. 翻訳ファイルの構造
```json
{
  "meta": {
    "title": "ページタイトル",
    "description": "ページの説明",
    "keywords": "キーワード1,キーワード2"
  },
  "title": "ツールタイトル",
  // ツール固有の翻訳
  "ui": {
    "title": "UIに表示するタイトル",
    // その他UIテキスト
  }
}
```

### 4. レイアウトファイル（layout.tsx）の実装
レイアウトファイルでは以下の作業を行います：

1. メタデータの生成
```tsx
export async function generateMetadata({ params }: Propse<Metadata> {
  const { lang } = await params;
  
  // 翻訳をロード
  await loadToolMessages(lang as Language, 'tool-name');
  
  // 翻訳関数
  const t = async (key: string) => await translate(lan  // 共通のメタデータ情報を設定
  const commonMeta = {
    siteName: await t('siteName'),
    publisher: await t('publisher'),
    logoAlt: await t('common.meta.logoAlt'),
  };

  // ページ固有のJSON-LDを定義
  const jsonLd = {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": await t('toolName.meta.title'),
    "description": await t('toolName.meta.description'),
    "url": `${SITE_CONFIG.baseURL}/${lang}/tool-path`,
    // その他のJSON-LD情報
  };

  // 共通のメタデータを取得
  const metadata = await getCommonMetadata(
    lang,
    commonMeta,
    {
      title:toolName.meta.title'),
      description: awaiName.meta.description'),
      keywords: await t('toolName.meta.keywords'),
      url: `${SITE_CONFIG.baseURL}/${lang}/tool-path`,
    }
  );

  return {
    ...metadata,
    other: {
      'application/ld+json': JSON.stringify(jsonLd)
    }
  };
}
```

2. クライアントコンポーネントで使用する翻訳の準備
サーバーコンポーネント側で文字列情報 [server.ts](mdc:src/lib/i18n/server.ts) から取得し、NextJSのScriptタグに`messages`を渡します。
```tsx
export default async function Layout({ children, params }: Props) {
  const { lang } = await params;
  
  // 翻訳をロード
  await loadToolMessages(lang as Language, 'tool-name');

  // 必要な翻訳を一括で取得
  const translations = await Promise.all([
    translate(lang, 'toolName.title'),
    translate(lang, 'toolName.ui.label1'),
    translate(lang, 'toolName.ui.label2'),
    // 必要な翻訳キーを追加
  ]);
  
  // 値を取り出し
  const [title, label1, label2] = translations;

  // クライアントコンポーネントに渡す翻訳データ
  const messages = {
    toolName: {
      title,
      ui: {
        label1,
        label2
      }
    }
  };

  return (
    <>
      {/* クライアントコンポーネントで使用する翻訳をスクリプトタグで埋め込み */}
      <Script
        id="messages"
        type="application/json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify(messages),
        }}
      />
      <div className="layout-container">
        <Header title={title} homeLink={`/${lang}/tool-path`} />
        <main>
          {children}
        </main>
        <Footer />
      </div>
    </>
  );
}
```

### 5. ページファイル（page.tsx）の実装
```tsx
import ToolComponent from './components/ToolComponent';
import { getLanguageFromParams } from '@/lib/i18n/server';

type Props = {
  params: { lang: string }
}

export default async function ToolPage({ params }: Props) {
  const lang = await getLanguageFromParams(params);

  return (
    <div className="container">
      <ToolComponent />
    </div>
  );
}
```

### 6. クライアントコンポーネントでの翻訳の使用
クライアントコンポーネントでは、`useMessages`フックを使用して翻訳を取得します：

```tsx
'use client';

import { useEffect, useState } from 'react';
import { useMessages } from '@/hooks/useMessages';

// メッセージの型定義
type ToolMessages = {
  toolName: {
    title: string;
    ui: {
      label1: string;
      label2: string;
    }
  }
}

export default function ToolComponent() {
  // 基本的な使い方（デフォルトのid="messages"を使用）
  const messages = useMessages<ToolMessages>();

  if (!messages) {
    return <div>Loading translations...</div>;
  }

  return (
    <div>
      <h1>{messages.toolName.title}</h1>
      <div>
        <label>{messages.toolName.ui.label1}</label>
        {/* その他のUIコンポーネント */}
      </div>
    </div>
  );
}
```

### 7. 親子レイアウトでのScript IDの衝突防止

Next.jsのネストされたレイアウト構造では、親レイアウト（例：`word-gen/layout.tsx`）と子レイアウト（例：`word-gen/word-card-generator/layout.tsx`）の両方がScriptタグを使用すると、同じID（`messages`）を持つタグが複数存在する状況が発生します。

この場合、`document.getElementById('messages')`は最初に見つかったScriptタグを取得するため、クライアントコンポーネントが意図しないメッセージを読み込む可能性があります。

**対策：固有のID名を使用する**

1. レイアウトファイル（layout.tsx）では、ツール固有のIDを使用します：

```tsx
// 例：word-gen/word-card-generator/layout.tsx
<Script
  id="word-card-generator-messages" // ツール名を含む固有ID
  type="application/json"
  dangerouslySetInnerHTML={{
    __html: JSON.stringify(messages),
  }}
/>
```

2. クライアントコンポーネントでは、そのIDを指定してuseMessagesを使用します：

```tsx
// 例：WordCardGeneratorClient.tsx
const messages = useMessages<WordCardGeneratorMessages>('word-card-generator-messages');
```

**命名規則**：
- 単一階層のツール: `{tool-name}-messages`
- ネストされたツール: `{parent-category}-{tool-name}-messages`

この方法により、親レイアウトと子レイアウトのScriptタグが互いに干渉せず、各コンポーネントが正しいメッセージを取得できます。

### 8. 新規言語追加時の手順
1. [types.ts](mdc:src/lib/i18n/types.ts) の`Language`型に新しい言語を追加
```typescript
export type Language = 'en' | 'ja' | 'es' | 'new_lang';
```
2. `assets/locales/`に新しい言語ディレクトリを作成（例：`fr/`）
3. 英語ディレクトリ（`en/`）の構造を複製し、すべてのファイルを新言語に翻訳
4. [server.ts](mdc:src/lib/i18n/server.ts) の`getAvailableLanguages`関数に新しい言語を追加
5. 言語切り替えコンポーネントに新しい言語を追加

### 9. 注意事項
- 翻訳漏れを防ぐため、新規テキスト追加時は必ずすべての言語ファイルを更新
- 言語ファイルのキー構造は全言語で統一
- 動的なテキストを含む場合は、プレースホルダーを使用
```json
{
  "welcome": "Welcome, {name}!"
}
```
- SEO対策として、各ページのメタデータも多言語対応
- レイアウトファイルで翻訳データを準備し、クライアントコンポーネントで使用

### 10. 重要なユーティリティ関数
| 関数名 | 用途 | パス |
|--------|------|------|
| `loadToolMessages` | ツール固有の翻訳をロード | `@/lib/i18n/server` |
| `translate` | サーバーコンポーネントでの翻訳取得 | `@/lib/i18n/server` |
| `getLanguageFromParams` | パラメータから言語情報を取得 | `@/lib/i18n/server` |
| `getAvailableLanguages` | 利用可能な言語一覧を取得 | `@/lib/i18n/server` |

### 11. 実装例
number-quizとcountry-dataの実装を参考にしてください。特に以下のファイルが参考になります：

- `app/[lang]/number-quiz/layout.tsx`
- `app/[lang]/number-quiz/page.tsx`
- `app/[lang]/number-quiz/components/SudokuGame.tsx`
- `app/[lang]/country-data/layout.tsx`
- `app/[lang]/country-data/page.tsx`

### 12. 翻訳の並列処理
翻訳処理のパフォーマンスを向上させるため、`Promise.all`を使用して並列処理を行います：

```typescript
// 非推奨：逐次的な翻訳処理
const translations = {
  title: await translate(lang, 'page.title'),
  description: await translate(lang, 'page.description'),
  button: await translate(lang, 'page.button'),
};

// 推奨：Promise.allを使用した並列処理
const [title, description, button] = await Promise.all([
  translate(lang, 'page.title'),
  translate(lang, 'page.description'),
  translate(lang, 'page.button'),
]);

const translations = {
  title,
  description,
  button,
};
```

#### 深いネストの翻訳処理
オブジェクトが深くネストされている場合は、以下のパターンを使用します：

```typescript
// 非推奨：深いネストでの逐次処理
const translations = {
  content: {
    hero: {
      title: await translate(lang, 'content.hero.title'),
      description: await translate(lang, 'content.hero.description'),
    },
    features: {
      title: await translate(lang, 'content.features.title'),
      items: {
        first: await translate(lang, 'content.features.items.first'),
        second: await translate(lang, 'content.features.items.second'),
      },
    },
  },
};

// 推奨：Promise.allとオブジェクトの分割代入を組み合わせた並列処理
const [
  heroTitle,
  heroDescription,
  featuresTitle,
  featuresItemFirst,
  featuresItemSecond,
] = await Promise.all([
  translate(lang, 'content.hero.title'),
  translate(lang, 'content.hero.description'),
  translate(lang, 'content.features.title'),
  translate(lang, 'content.features.items.first'),
  translate(lang, 'content.features.items.second'),
]);

const translations = {
  content: {
    hero: {
      title: heroTitle,
      description: heroDescription,
    },
    features: {
      title: featuresTitle,
      items: {
        first: featuresItemFirst,
        second: featuresItemSecond,
      },
    },
  },
};
```

このパターンを使用することで：
- 翻訳処理が並列化され、パフォーマンスが向上
- コードの可読性が向上
- デバッグが容易になる（各翻訳キーと変数の対応が明確） 